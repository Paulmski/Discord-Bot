# file app/__main__.py

def main():

    from discord.ext.commands import Bot
    from discord.ext import tasks, commands
    import discord.utils
    from discord.http import Route
    import random
    import os
    from dotenv import load_dotenv
    import gsapi_builder
    import sheets_parser
    from datetime import datetime
    from time import sleep
    import logging
    import events as events

    random.seed() # Seed the RNG.
    load_dotenv()

    # Getting environment variables.
    SPREADSHEET_ID = os.getenv("SPREADSHEET_ID")
    RANGE_NAME = os.getenv("RANGE_NAME")
    COURSE_SHEET = os.getenv("COURSE_SHEET")
    DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
    ANNOUNCEMENT_CHANNEL = os.getenv("ANNOUNCEMENT_CHANNEL")
    GUILD_ID = int(os.getenv("GUILD_ID"))

    # Logging formating to view time stamps and level of log information
    logging.basicConfig(
         format='%(asctime)s %(levelname)-8s %(message)s',
         level=logging.INFO,
         datefmt='%Y-%m-%d %H:%M:%S')

    # Build the Google Sheets API service.
    service = gsapi_builder.build_service()

    # Instantiate the bot, with the ! prefix preferred.
    bot = Bot(command_prefix='!')

    # Print the bot information upon bootup.
    @bot.event
    async def on_ready():
        logging.info('\nLogged in as\n' + bot.user.name)
        logging.debug(bot.user.id)
        print('------')

    # Print that the bot is connected to the server.
    @bot.event
    async def on_connect():
        logging.info("--Connected to server--")

    # Flip a coin and tell the user what the result was.
    @bot.command(pass_context=True)
    async def coinflip(ctx):
        '''
        According to Teare and Murray's "Probability of a tossed coin landing on edge", extrapolations from a physical simulation model suggests "that the probability of an American nickel landing on edge is approximately 1 in 6000 tosses."
        Murray, Daniel B., and Scott W. Teare. “Probability of a Tossed Coin Landing on Edge.” Physical Review E, vol. 48, no. 4, 1993, pp. 2547–2552., https://doi.org/10.1103/physreve.48.2547.
        '''
        rand = random.randint(0, 6000)
        if rand == 777:
            responses = ['Holy cow, it landed on it\'s side!', 'You won\'t believe this but it landed on its side!', 'Despite all odds, it landed on it\'s side!']
            random_response = random.choice([0, len(responses)])
            await ctx.channel.send(responses[random_response])
        elif rand % 2 == 0:
            await ctx.channel.send('Heads!')
        elif rand % 2 == 1:
            await ctx.channel.send('Tails!')

    # Command to make an announcement to whole server, but in a specific channel.
    @bot.command(pass_context=True)
    async def announce(ctx, subCommand: str, subSubCommand: str, arg: str):
        # Used to configure settings related to this command.
        if (subCommand == 'config'):
            # Used to configure which channel the bot should make announcements too.
            if (subSubCommand == 'channel'):
                # TODO: Allow for the ability to modify channel for announcement.
                channel = discord.utils.get(ctx.guild.channels, name=arg)
                await channel.send('This is the new announcement channel.')

    # Command to to fetch due dates on demand.
    @bot.command(pass_context=True)
    async def homework(ctx):
        await fetcher.fetch_due_dates(channel_id=ctx.channel.id)



    @bot.command(pass_context=True)
    async def list(ctx, code=None):
        if code == None:
            await ctx.channel.send('Invalid code entered, make sure you have the right course code e.g. "!list comp1271".')
            return
        
        code = code.upper()


        assignments = sheets_parser.fetch_assignments(service, SPREADSHEET_ID, RANGE_NAME)
        final_assignments = []
        # Remove all courses that don't have a matching course code
        if code == 'ALL':
            final_assignments = assignments
        else:
            for assignment in assignments:
             
                print(vars(assignment))
                if assignment.code == code:
                    final_assignments.append(assignment)





        # No matching assignments found.
        if final_assignments == []:
            await ctx.channel.send('Could\'nt find any assignments matching the course code "{}".'.format(code))
            return
        title = "Assignments for {}".format(code)
        await fetcher.announce_assignments(final_assignments, title=title, channel_id=ctx.channel.id)
        





    # Print the message back.
    @bot.command(pass_context=True)
    async def repeat(ctx, *, arg):
        await ctx.send(arg)

    # Command to debug Event Scheduling.
    # @bot.command(pass_context=True)
    # async def schedule(ctx):
    #     await scheduler.schedule_events()

    # Instantiate FetchDate and EventScheduler class.
    fetcher = events.FetchDate(service=service, bot=bot)
    scheduler = events.EventScheduler(service=service, bot=bot)

    # Run the bot using the DISCORD_TOKEN constant from .env.
    bot.run(DISCORD_TOKEN)

if __name__ == '__main__':
  main()
